---
title: "Chapter 01"
author: "Lachlan Deer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Chapter 01}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Application: Returns to Scale in Electricity Supply 

Load the `hayashir` package
```{r}
library(hayashir)
```

## The Data

Let's get a quick look at our data by looking at the first 10 rows:

```{r, results='asis'}
knitr::kable(head(nerlove, 10))
```

Some information about the variables in the data can be found in the documentation:

```{r}
?nerlove
```

And we can gain an understanding of the structure of our data by:

```{r}
str(nerlove)

```

And by using the `skim` command from the `skimr` package we can look at summary statistics:

```{r}
# install.packages("skimr")
library(skimr)

skim(nerlove)
```

## Testing Homogeneity of the cost function

### Unrestricted
```{r}
unrestricted_ls <- log(total_cost ) ~ log(output ) + log(price_labor ) + log(price_capital ) + log(price_fuel)

model1 <- lm(unrestricted_ls, data = nerlove)
summary(model1)

```

Scale Coefficient:
```{r}
return_to_scale <- 1 / model1$coefficients[2]
print(return_to_scale)
```

t-stat:
```{r}
library(car)

linearHypothesis(model1, c("log(price_capital) = 0" ))

# relationship between t and F = F = t^2

test_results <- linearHypothesis(model1, c("log(price_capital) = 0" ))

# ie. same as above
t_stat <- sqrt(test_results$F)

```

## Restricted Model

Following the book:
```{r}
restricted_ls <- log(total_cost /price_fuel) ~ log(output) + log(price_labor / price_fuel) + log(price_capital / price_fuel) 

model2 <- lm(restricted_ls, data = nerlove)
summary(model2)
```

We can find SSR from the `anova function:`
```{r}
anova(model1)
```

We need to get SSR_u from model 1 and the denominator df:
```{r}
anova_model1 <- anova(model1)
nrow(anova_model1)

SSR_u <- anova_model1$`Sum Sq`[nrow(anova_model1)]
df_resid_u <- anova_model1$Df[nrow(anova_model1)]
```

and for the restricted model:
```{r}
anova_model2 <- anova(model2)
nrow(anova_model2)

SSR_r <- anova_model2$`Sum Sq`[nrow(anova_model2)]
df_resid_r <- anova_model2$Df[nrow(anova_model2)]
```

Then our F-stat is:
```{r}
f_stat <- ( (SSR_r - SSR_u) / (df_resid_r - df_resid_u)) / (SSR_u / (df_resid_u))
print(paste("F stat is:", f_stat))
```

Which has a p-value of 
```{r}
pf(f_stat, df_resid_r - df_resid_u, df_resid_u, lower.tail = FALSE)
```


Alternatively the critical value at 5% is
```{r}
qf(0.05, df_resid_r - df_resid_u, df_resid_u, lower.tail = FALSE)
```

### Easier way!
That was all kind of *complicated* ... a simpler version would be using the `linearHypothesis` function from above by specifying the restriction we want to impose

```{r}
linearHypothesis(model1, "log(price_labor) + log(price_capital) + log(price_fuel) = 1")
```

## Detour: a cautionary note on $R^2$

```{r}
scale_effect <- log(total_cost / output) ~ log(output ) + log(price_labor ) + log(price_capital ) + log(price_fuel)

model3 <- lm(scale_effect, data = nerlove)
summary(model3)
```

## Testing Constant Returns to Scale

```{r}
linearHypothesis(model2, "log(output) = 1")
```

Which again returns an F-stat. 
We can map that into a t-stat as follows:

```{r}
f_stat2 <- linearHypothesis(model2, "log(output) = 1")

t_stat2 <- sqrt(f_stat2$F[2])

print(paste("t stat is:", t_stat2))

```

## Importance of plotting residuals

```{r, fig.height= 6, fig.width=6}
# residual plot comes from car package
residualPlot(model2, variable = "log(output)")
```